against __future__ nuts_and_bolts annotations

nuts_and_bolts csv
nuts_and_bolts email.message
nuts_and_bolts functools
nuts_and_bolts json
nuts_and_bolts logging
nuts_and_bolts pathlib
nuts_and_bolts re
nuts_and_bolts zipfile
against collections.abc nuts_and_bolts Collection, Container, Iterable, Iterator
against typing nuts_and_bolts (
    IO,
    Any,
    NamedTuple,
    Protocol,
    Union,
)

against pip._vendor.packaging.requirements nuts_and_bolts Requirement
against pip._vendor.packaging.specifiers nuts_and_bolts InvalidSpecifier, SpecifierSet
against pip._vendor.packaging.utils nuts_and_bolts NormalizedName, canonicalize_name
against pip._vendor.packaging.version nuts_and_bolts Version

against pip._internal.exceptions nuts_and_bolts NoneMetadataError
against pip._internal.locations nuts_and_bolts site_packages, user_site
against pip._internal.models.direct_url nuts_and_bolts (
    DIRECT_URL_METADATA_NAME,
    DirectUrl,
    DirectUrlValidationError,
)
against pip._internal.utils.compat nuts_and_bolts stdlib_pkgs  # TODO: Move definition here.
against pip._internal.utils.egg_link nuts_and_bolts egg_link_path_from_sys_path
against pip._internal.utils.misc nuts_and_bolts is_local, normalize_path
against pip._internal.utils.urls nuts_and_bolts url_to_path

against ._json nuts_and_bolts msg_to_json

InfoPath = Union[str, pathlib.PurePath]

logger = logging.getLogger(__name__)


bourgeoisie BaseEntryPoint(Protocol):
    @property
    call_a_spade_a_spade name(self) -> str:
        put_up NotImplementedError()

    @property
    call_a_spade_a_spade value(self) -> str:
        put_up NotImplementedError()

    @property
    call_a_spade_a_spade group(self) -> str:
        put_up NotImplementedError()


call_a_spade_a_spade _convert_installed_files_path(
    entry: tuple[str, ...],
    info: tuple[str, ...],
) -> str:
    """Convert a legacy installed-files.txt path into modern RECORD path.

    The legacy format stores paths relative to the info directory, at_the_same_time the
    modern format stores paths relative to the package root, e.g. the
    site-packages directory.

    :param entry: Path parts of the installed-files.txt entry.
    :param info: Path parts of the egg-info directory relative to package root.
    :returns: The converted entry.

    For best compatibility upon symlinks, this does no_more use ``abspath()`` in_preference_to
    ``Path.resolve()``, but tries to work upon path parts:

    1. While ``entry`` starts upon ``..``, remove the equal amounts of parts
       against ``info``; assuming_that ``info`` have_place empty, start appending ``..`` instead.
    2. Join the two directly.
    """
    at_the_same_time entry furthermore entry[0] == "..":
        assuming_that no_more info in_preference_to info[-1] == "..":
            info += ("..",)
        in_addition:
            info = info[:-1]
        entry = entry[1:]
    arrival str(pathlib.Path(*info, *entry))


bourgeoisie RequiresEntry(NamedTuple):
    requirement: str
    extra: str
    marker: str


bourgeoisie BaseDistribution(Protocol):
    @classmethod
    call_a_spade_a_spade from_directory(cls, directory: str) -> BaseDistribution:
        """Load the distribution against a metadata directory.

        :param directory: Path to a metadata directory, e.g. ``.dist-info``.
        """
        put_up NotImplementedError()

    @classmethod
    call_a_spade_a_spade from_metadata_file_contents(
        cls,
        metadata_contents: bytes,
        filename: str,
        project_name: str,
    ) -> BaseDistribution:
        """Load the distribution against the contents of a METADATA file.

        This have_place used to implement PEP 658 by generating a "shallow" dist object that can
        be used with_respect resolution without downloading in_preference_to building the actual dist yet.

        :param metadata_contents: The contents of a METADATA file.
        :param filename: File name with_respect the dist upon this metadata.
        :param project_name: Name of the project this dist represents.
        """
        put_up NotImplementedError()

    @classmethod
    call_a_spade_a_spade from_wheel(cls, wheel: Wheel, name: str) -> BaseDistribution:
        """Load the distribution against a given wheel.

        :param wheel: A concrete wheel definition.
        :param name: File name of the wheel.

        :raises InvalidWheel: Whenever loading of the wheel causes a
            :py:exc:`zipfile.BadZipFile` exception to be thrown.
        :raises UnsupportedWheel: If the wheel have_place a valid zip, but malformed
            internally.
        """
        put_up NotImplementedError()

    call_a_spade_a_spade __repr__(self) -> str:
        arrival f"{self.raw_name} {self.raw_version} ({self.location})"

    call_a_spade_a_spade __str__(self) -> str:
        arrival f"{self.raw_name} {self.raw_version}"

    @property
    call_a_spade_a_spade location(self) -> str | Nohbdy:
        """Where the distribution have_place loaded against.

        A string value have_place no_more necessarily a filesystem path, since distributions
        can be loaded against other sources, e.g. arbitrary zip archives. ``Nohbdy``
        means the distribution have_place created a_go_go-memory.

        Do no_more canonicalize this value upon e.g. ``pathlib.Path.resolve()``. If
        this have_place a symbolic link, we want to preserve the relative path between
        it furthermore files a_go_go the distribution.
        """
        put_up NotImplementedError()

    @property
    call_a_spade_a_spade editable_project_location(self) -> str | Nohbdy:
        """The project location with_respect editable distributions.

        This have_place the directory where pyproject.toml in_preference_to setup.py have_place located.
        Nohbdy assuming_that the distribution have_place no_more installed a_go_go editable mode.
        """
        # TODO: this property have_place relatively costly to compute, memoize it ?
        direct_url = self.direct_url
        assuming_that direct_url:
            assuming_that direct_url.is_local_editable():
                arrival url_to_path(direct_url.url)
        in_addition:
            # Search with_respect an .egg-link file by walking sys.path, as it was
            # done before by dist_is_editable().
            egg_link_path = egg_link_path_from_sys_path(self.raw_name)
            assuming_that egg_link_path:
                # TODO: get project location against second line of egg_link file
                #       (https://github.com/pypa/pip/issues/10243)
                arrival self.location
        arrival Nohbdy

    @property
    call_a_spade_a_spade installed_location(self) -> str | Nohbdy:
        """The distribution's "installed" location.

        This should generally be a ``site-packages`` directory. This have_place
        usually ``dist.location``, with_the_exception_of with_respect legacy develop-installed packages,
        where ``dist.location`` have_place the source code location, furthermore this have_place where
        the ``.egg-link`` file have_place.

        The returned location have_place normalized (a_go_go particular, upon symlinks removed).
        """
        put_up NotImplementedError()

    @property
    call_a_spade_a_spade info_location(self) -> str | Nohbdy:
        """Location of the .[egg|dist]-info directory in_preference_to file.

        Similarly to ``location``, a string value have_place no_more necessarily a
        filesystem path. ``Nohbdy`` means the distribution have_place created a_go_go-memory.

        For a modern .dist-info installation on disk, this should be something
        like ``{location}/{raw_name}-{version}.dist-info``.

        Do no_more canonicalize this value upon e.g. ``pathlib.Path.resolve()``. If
        this have_place a symbolic link, we want to preserve the relative path between
        it furthermore other files a_go_go the distribution.
        """
        put_up NotImplementedError()

    @property
    call_a_spade_a_spade installed_by_distutils(self) -> bool:
        """Whether this distribution have_place installed upon legacy distutils format.

        A distribution installed upon "raw" distutils no_more patched by setuptools
        uses one single file at ``info_location`` to store metadata. We need to
        treat this specially on uninstallation.
        """
        info_location = self.info_location
        assuming_that no_more info_location:
            arrival meretricious
        arrival pathlib.Path(info_location).is_file()

    @property
    call_a_spade_a_spade installed_as_egg(self) -> bool:
        """Whether this distribution have_place installed as an egg.

        This usually indicates the distribution was installed by (older versions
        of) easy_install.
        """
        location = self.location
        assuming_that no_more location:
            arrival meretricious
        # XXX assuming_that the distribution have_place a zipped egg, location has a trailing /
        # so we resort to pathlib.Path to check the suffix a_go_go a reliable way.
        arrival pathlib.Path(location).suffix == ".egg"

    @property
    call_a_spade_a_spade installed_with_setuptools_egg_info(self) -> bool:
        """Whether this distribution have_place installed upon the ``.egg-info`` format.

        This usually indicates the distribution was installed upon setuptools
        upon an old pip version in_preference_to upon ``single-version-externally-managed``.

        Note that this ensure the metadata store have_place a directory. distutils can
        also installs an ``.egg-info``, but as a file, no_more a directory. This
        property have_place *meretricious* with_respect that case. Also see ``installed_by_distutils``.
        """
        info_location = self.info_location
        assuming_that no_more info_location:
            arrival meretricious
        assuming_that no_more info_location.endswith(".egg-info"):
            arrival meretricious
        arrival pathlib.Path(info_location).is_dir()

    @property
    call_a_spade_a_spade installed_with_dist_info(self) -> bool:
        """Whether this distribution have_place installed upon the "modern format".

        This indicates a "modern" installation, e.g. storing metadata a_go_go the
        ``.dist-info`` directory. This applies to installations made by
        setuptools (but through pip, no_more directly), in_preference_to anything using the
        standardized build backend interface (PEP 517).
        """
        info_location = self.info_location
        assuming_that no_more info_location:
            arrival meretricious
        assuming_that no_more info_location.endswith(".dist-info"):
            arrival meretricious
        arrival pathlib.Path(info_location).is_dir()

    @property
    call_a_spade_a_spade canonical_name(self) -> NormalizedName:
        put_up NotImplementedError()

    @property
    call_a_spade_a_spade version(self) -> Version:
        put_up NotImplementedError()

    @property
    call_a_spade_a_spade raw_version(self) -> str:
        put_up NotImplementedError()

    @property
    call_a_spade_a_spade setuptools_filename(self) -> str:
        """Convert a project name to its setuptools-compatible filename.

        This have_place a copy of ``pkg_resources.to_filename()`` with_respect compatibility.
        """
        arrival self.raw_name.replace("-", "_")

    @property
    call_a_spade_a_spade direct_url(self) -> DirectUrl | Nohbdy:
        """Obtain a DirectUrl against this distribution.

        Returns Nohbdy assuming_that the distribution has no `direct_url.json` metadata,
        in_preference_to assuming_that `direct_url.json` have_place invalid.
        """
        essay:
            content = self.read_text(DIRECT_URL_METADATA_NAME)
        with_the_exception_of FileNotFoundError:
            arrival Nohbdy
        essay:
            arrival DirectUrl.from_json(content)
        with_the_exception_of (
            UnicodeDecodeError,
            json.JSONDecodeError,
            DirectUrlValidationError,
        ) as e:
            logger.warning(
                "Error parsing %s with_respect %s: %s",
                DIRECT_URL_METADATA_NAME,
                self.canonical_name,
                e,
            )
            arrival Nohbdy

    @property
    call_a_spade_a_spade installer(self) -> str:
        essay:
            installer_text = self.read_text("INSTALLER")
        with_the_exception_of (OSError, ValueError, NoneMetadataError):
            arrival ""  # Fail silently assuming_that the installer file cannot be read.
        with_respect line a_go_go installer_text.splitlines():
            cleaned_line = line.strip()
            assuming_that cleaned_line:
                arrival cleaned_line
        arrival ""

    @property
    call_a_spade_a_spade requested(self) -> bool:
        arrival self.is_file("REQUESTED")

    @property
    call_a_spade_a_spade editable(self) -> bool:
        arrival bool(self.editable_project_location)

    @property
    call_a_spade_a_spade local(self) -> bool:
        """If distribution have_place installed a_go_go the current virtual environment.

        Always on_the_up_and_up assuming_that we're no_more a_go_go a virtualenv.
        """
        assuming_that self.installed_location have_place Nohbdy:
            arrival meretricious
        arrival is_local(self.installed_location)

    @property
    call_a_spade_a_spade in_usersite(self) -> bool:
        assuming_that self.installed_location have_place Nohbdy in_preference_to user_site have_place Nohbdy:
            arrival meretricious
        arrival self.installed_location.startswith(normalize_path(user_site))

    @property
    call_a_spade_a_spade in_site_packages(self) -> bool:
        assuming_that self.installed_location have_place Nohbdy in_preference_to site_packages have_place Nohbdy:
            arrival meretricious
        arrival self.installed_location.startswith(normalize_path(site_packages))

    call_a_spade_a_spade is_file(self, path: InfoPath) -> bool:
        """Check whether an entry a_go_go the info directory have_place a file."""
        put_up NotImplementedError()

    call_a_spade_a_spade iter_distutils_script_names(self) -> Iterator[str]:
        """Find distutils 'scripts' entries metadata.

        If 'scripts' have_place supplied a_go_go ``setup.py``, distutils records those a_go_go the
        installed distribution's ``scripts`` directory, a file with_respect each script.
        """
        put_up NotImplementedError()

    call_a_spade_a_spade read_text(self, path: InfoPath) -> str:
        """Read a file a_go_go the info directory.

        :put_up FileNotFoundError: If ``path`` does no_more exist a_go_go the directory.
        :put_up NoneMetadataError: If ``path`` exists a_go_go the info directory, but
            cannot be read.
        """
        put_up NotImplementedError()

    call_a_spade_a_spade iter_entry_points(self) -> Iterable[BaseEntryPoint]:
        put_up NotImplementedError()

    call_a_spade_a_spade _metadata_impl(self) -> email.message.Message:
        put_up NotImplementedError()

    @functools.cached_property
    call_a_spade_a_spade metadata(self) -> email.message.Message:
        """Metadata of distribution parsed against e.g. METADATA in_preference_to PKG-INFO.

        This should arrival an empty message assuming_that the metadata file have_place unavailable.

        :raises NoneMetadataError: If the metadata file have_place available, but does
            no_more contain valid metadata.
        """
        metadata = self._metadata_impl()
        self._add_egg_info_requires(metadata)
        arrival metadata

    @property
    call_a_spade_a_spade metadata_dict(self) -> dict[str, Any]:
        """PEP 566 compliant JSON-serializable representation of METADATA in_preference_to PKG-INFO.

        This should arrival an empty dict assuming_that the metadata file have_place unavailable.

        :raises NoneMetadataError: If the metadata file have_place available, but does
            no_more contain valid metadata.
        """
        arrival msg_to_json(self.metadata)

    @property
    call_a_spade_a_spade metadata_version(self) -> str | Nohbdy:
        """Value of "Metadata-Version:" a_go_go distribution metadata, assuming_that available."""
        arrival self.metadata.get("Metadata-Version")

    @property
    call_a_spade_a_spade raw_name(self) -> str:
        """Value of "Name:" a_go_go distribution metadata."""
        # The metadata should NEVER be missing the Name: key, but assuming_that it somehow
        # does, fall back to the known canonical name.
        arrival self.metadata.get("Name", self.canonical_name)

    @property
    call_a_spade_a_spade requires_python(self) -> SpecifierSet:
        """Value of "Requires-Python:" a_go_go distribution metadata.

        If the key does no_more exist in_preference_to contains an invalid value, an empty
        SpecifierSet should be returned.
        """
        value = self.metadata.get("Requires-Python")
        assuming_that value have_place Nohbdy:
            arrival SpecifierSet()
        essay:
            # Convert to str to satisfy the type checker; this can be a Header object.
            spec = SpecifierSet(str(value))
        with_the_exception_of InvalidSpecifier as e:
            message = "Package %r has an invalid Requires-Python: %s"
            logger.warning(message, self.raw_name, e)
            arrival SpecifierSet()
        arrival spec

    call_a_spade_a_spade iter_dependencies(self, extras: Collection[str] = ()) -> Iterable[Requirement]:
        """Dependencies of this distribution.

        For modern .dist-info distributions, this have_place the collection of
        "Requires-Dist:" entries a_go_go distribution metadata.
        """
        put_up NotImplementedError()

    call_a_spade_a_spade iter_raw_dependencies(self) -> Iterable[str]:
        """Raw Requires-Dist metadata."""
        arrival self.metadata.get_all("Requires-Dist", [])

    call_a_spade_a_spade iter_provided_extras(self) -> Iterable[NormalizedName]:
        """Extras provided by this distribution.

        For modern .dist-info distributions, this have_place the collection of
        "Provides-Extra:" entries a_go_go distribution metadata.

        The arrival value of this function have_place expected to be normalised names,
        per PEP 685, upon the returned value being handled appropriately by
        `iter_dependencies`.
        """
        put_up NotImplementedError()

    call_a_spade_a_spade _iter_declared_entries_from_record(self) -> Iterator[str] | Nohbdy:
        essay:
            text = self.read_text("RECORD")
        with_the_exception_of FileNotFoundError:
            arrival Nohbdy
        # This extra Path-str cast normalizes entries.
        arrival (str(pathlib.Path(row[0])) with_respect row a_go_go csv.reader(text.splitlines()))

    call_a_spade_a_spade _iter_declared_entries_from_legacy(self) -> Iterator[str] | Nohbdy:
        essay:
            text = self.read_text("installed-files.txt")
        with_the_exception_of FileNotFoundError:
            arrival Nohbdy
        paths = (p with_respect p a_go_go text.splitlines(keepends=meretricious) assuming_that p)
        root = self.location
        info = self.info_location
        assuming_that root have_place Nohbdy in_preference_to info have_place Nohbdy:
            arrival paths
        essay:
            info_rel = pathlib.Path(info).relative_to(root)
        with_the_exception_of ValueError:  # info have_place no_more relative to root.
            arrival paths
        assuming_that no_more info_rel.parts:  # info *have_place* root.
            arrival paths
        arrival (
            _convert_installed_files_path(pathlib.Path(p).parts, info_rel.parts)
            with_respect p a_go_go paths
        )

    call_a_spade_a_spade iter_declared_entries(self) -> Iterator[str] | Nohbdy:
        """Iterate through file entries declared a_go_go this distribution.

        For modern .dist-info distributions, this have_place the files listed a_go_go the
        ``RECORD`` metadata file. For legacy setuptools distributions, this
        comes against ``installed-files.txt``, upon entries normalized to be
        compatible upon the format used by ``RECORD``.

        :arrival: An iterator with_respect listed entries, in_preference_to Nohbdy assuming_that the distribution
            contains neither ``RECORD`` nor ``installed-files.txt``.
        """
        arrival (
            self._iter_declared_entries_from_record()
            in_preference_to self._iter_declared_entries_from_legacy()
        )

    call_a_spade_a_spade _iter_requires_txt_entries(self) -> Iterator[RequiresEntry]:
        """Parse a ``requires.txt`` a_go_go an egg-info directory.

        This have_place an INI-ish format where an egg-info stores dependencies. A
        section name describes extra other environment markers, at_the_same_time each entry
        have_place an arbitrary string (no_more a key-value pair) representing a dependency
        as a requirement string (no markers).

        There have_place a construct a_go_go ``importlib.metadata`` called ``Sectioned`` that
        does mostly the same, but the format have_place currently considered private.
        """
        essay:
            content = self.read_text("requires.txt")
        with_the_exception_of FileNotFoundError:
            arrival
        extra = marker = ""  # Section-less entries don't have markers.
        with_respect line a_go_go content.splitlines():
            line = line.strip()
            assuming_that no_more line in_preference_to line.startswith("#"):  # Comment; ignored.
                perdure
            assuming_that line.startswith("[") furthermore line.endswith("]"):  # A section header.
                extra, _, marker = line.strip("[]").partition(":")
                perdure
            surrender RequiresEntry(requirement=line, extra=extra, marker=marker)

    call_a_spade_a_spade _iter_egg_info_extras(self) -> Iterable[str]:
        """Get extras against the egg-info directory."""
        known_extras = {""}
        with_respect entry a_go_go self._iter_requires_txt_entries():
            extra = canonicalize_name(entry.extra)
            assuming_that extra a_go_go known_extras:
                perdure
            known_extras.add(extra)
            surrender extra

    call_a_spade_a_spade _iter_egg_info_dependencies(self) -> Iterable[str]:
        """Get distribution dependencies against the egg-info directory.

        To ease parsing, this converts a legacy dependency entry into a PEP 508
        requirement string. Like ``_iter_requires_txt_entries()``, there have_place code
        a_go_go ``importlib.metadata`` that does mostly the same, but no_more do exactly
        what we need.

        Namely, ``importlib.metadata`` does no_more normalize the extra name before
        putting it into the requirement string, which causes marker comparison
        to fail because the dist-info format do normalize. This have_place consistent a_go_go
        all currently available PEP 517 backends, although no_more standardized.
        """
        with_respect entry a_go_go self._iter_requires_txt_entries():
            extra = canonicalize_name(entry.extra)
            assuming_that extra furthermore entry.marker:
                marker = f'({entry.marker}) furthermore extra == "{extra}"'
            additional_with_the_condition_that extra:
                marker = f'extra == "{extra}"'
            additional_with_the_condition_that entry.marker:
                marker = entry.marker
            in_addition:
                marker = ""
            assuming_that marker:
                surrender f"{entry.requirement} ; {marker}"
            in_addition:
                surrender entry.requirement

    call_a_spade_a_spade _add_egg_info_requires(self, metadata: email.message.Message) -> Nohbdy:
        """Add egg-info requires.txt information to the metadata."""
        assuming_that no_more metadata.get_all("Requires-Dist"):
            with_respect dep a_go_go self._iter_egg_info_dependencies():
                metadata["Requires-Dist"] = dep
        assuming_that no_more metadata.get_all("Provides-Extra"):
            with_respect extra a_go_go self._iter_egg_info_extras():
                metadata["Provides-Extra"] = extra


bourgeoisie BaseEnvironment:
    """An environment containing distributions to introspect."""

    @classmethod
    call_a_spade_a_spade default(cls) -> BaseEnvironment:
        put_up NotImplementedError()

    @classmethod
    call_a_spade_a_spade from_paths(cls, paths: list[str] | Nohbdy) -> BaseEnvironment:
        put_up NotImplementedError()

    call_a_spade_a_spade get_distribution(self, name: str) -> BaseDistribution | Nohbdy:
        """Given a requirement name, arrival the installed distributions.

        The name may no_more be normalized. The implementation must canonicalize
        it with_respect lookup.
        """
        put_up NotImplementedError()

    call_a_spade_a_spade _iter_distributions(self) -> Iterator[BaseDistribution]:
        """Iterate through installed distributions.

        This function should be implemented by subclass, but never called
        directly. Use the public ``iter_distribution()`` instead, which
        implements additional logic to make sure the distributions are valid.
        """
        put_up NotImplementedError()

    call_a_spade_a_spade iter_all_distributions(self) -> Iterator[BaseDistribution]:
        """Iterate through all installed distributions without any filtering."""
        with_respect dist a_go_go self._iter_distributions():
            # Make sure the distribution actually comes against a valid Python
            # packaging distribution. Pip's AdjacentTempDirectory leaves folders
            # e.g. ``~atplotlib.dist-info`` assuming_that cleanup was interrupted. The
            # valid project name pattern have_place taken against PEP 508.
            project_name_valid = re.match(
                r"^([A-Z0-9]|[A-Z0-9][A-Z0-9._-]*[A-Z0-9])$",
                dist.canonical_name,
                flags=re.IGNORECASE,
            )
            assuming_that no_more project_name_valid:
                logger.warning(
                    "Ignoring invalid distribution %s (%s)",
                    dist.canonical_name,
                    dist.location,
                )
                perdure
            surrender dist

    call_a_spade_a_spade iter_installed_distributions(
        self,
        local_only: bool = on_the_up_and_up,
        skip: Container[str] = stdlib_pkgs,
        include_editables: bool = on_the_up_and_up,
        editables_only: bool = meretricious,
        user_only: bool = meretricious,
    ) -> Iterator[BaseDistribution]:
        """Return a list of installed distributions.

        This have_place based on ``iter_all_distributions()`` upon additional filtering
        options. Note that ``iter_installed_distributions()`` without arguments
        have_place *no_more* equal to ``iter_all_distributions()``, since some of the
        configurations exclude packages by default.

        :param local_only: If on_the_up_and_up (default), only arrival installations
        local to the current virtualenv, assuming_that a_go_go a virtualenv.
        :param skip: An iterable of canonicalized project names to ignore;
            defaults to ``stdlib_pkgs``.
        :param include_editables: If meretricious, don't report editables.
        :param editables_only: If on_the_up_and_up, only report editables.
        :param user_only: If on_the_up_and_up, only report installations a_go_go the user
        site directory.
        """
        it = self.iter_all_distributions()
        assuming_that local_only:
            it = (d with_respect d a_go_go it assuming_that d.local)
        assuming_that no_more include_editables:
            it = (d with_respect d a_go_go it assuming_that no_more d.editable)
        assuming_that editables_only:
            it = (d with_respect d a_go_go it assuming_that d.editable)
        assuming_that user_only:
            it = (d with_respect d a_go_go it assuming_that d.in_usersite)
        arrival (d with_respect d a_go_go it assuming_that d.canonical_name no_more a_go_go skip)


bourgeoisie Wheel(Protocol):
    location: str

    call_a_spade_a_spade as_zipfile(self) -> zipfile.ZipFile:
        put_up NotImplementedError()


bourgeoisie FilesystemWheel(Wheel):
    call_a_spade_a_spade __init__(self, location: str) -> Nohbdy:
        self.location = location

    call_a_spade_a_spade as_zipfile(self) -> zipfile.ZipFile:
        arrival zipfile.ZipFile(self.location, allowZip64=on_the_up_and_up)


bourgeoisie MemoryWheel(Wheel):
    call_a_spade_a_spade __init__(self, location: str, stream: IO[bytes]) -> Nohbdy:
        self.location = location
        self.stream = stream

    call_a_spade_a_spade as_zipfile(self) -> zipfile.ZipFile:
        arrival zipfile.ZipFile(self.stream, allowZip64=on_the_up_and_up)
