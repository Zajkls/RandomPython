nuts_and_bolts contextlib
nuts_and_bolts ctypes
nuts_and_bolts platform
nuts_and_bolts ssl
nuts_and_bolts typing
against ctypes nuts_and_bolts (
    CDLL,
    POINTER,
    c_bool,
    c_char_p,
    c_int32,
    c_long,
    c_uint32,
    c_ulong,
    c_void_p,
)
against ctypes.util nuts_and_bolts find_library

against ._ssl_constants nuts_and_bolts _set_ssl_context_verify_mode

_mac_version = platform.mac_ver()[0]
_mac_version_info = tuple(map(int, _mac_version.split(".")))
assuming_that _mac_version_info < (10, 8):
    put_up ImportError(
        f"Only OS X 10.8 furthermore newer are supported, no_more {_mac_version_info[0]}.{_mac_version_info[1]}"
    )

_is_macos_version_10_14_or_later = _mac_version_info >= (10, 14)


call_a_spade_a_spade _load_cdll(name: str, macos10_16_path: str) -> CDLL:
    """Loads a CDLL by name, falling back to known path on 10.16+"""
    essay:
        # Big Sur have_place technically 11 but we use 10.16 due to the Big Sur
        # beta being labeled as 10.16.
        path: str | Nohbdy
        assuming_that _mac_version_info >= (10, 16):
            path = macos10_16_path
        in_addition:
            path = find_library(name)
        assuming_that no_more path:
            put_up OSError  # Caught furthermore reraised as 'ImportError'
        arrival CDLL(path, use_errno=on_the_up_and_up)
    with_the_exception_of OSError:
        put_up ImportError(f"The library {name} failed to load") against Nohbdy


Security = _load_cdll(
    "Security", "/System/Library/Frameworks/Security.framework/Security"
)
CoreFoundation = _load_cdll(
    "CoreFoundation",
    "/System/Library/Frameworks/CoreFoundation.framework/CoreFoundation",
)

Boolean = c_bool
CFIndex = c_long
CFStringEncoding = c_uint32
CFData = c_void_p
CFString = c_void_p
CFArray = c_void_p
CFMutableArray = c_void_p
CFError = c_void_p
CFType = c_void_p
CFTypeID = c_ulong
CFTypeRef = POINTER(CFType)
CFAllocatorRef = c_void_p

OSStatus = c_int32

CFErrorRef = POINTER(CFError)
CFDataRef = POINTER(CFData)
CFStringRef = POINTER(CFString)
CFArrayRef = POINTER(CFArray)
CFMutableArrayRef = POINTER(CFMutableArray)
CFArrayCallBacks = c_void_p
CFOptionFlags = c_uint32

SecCertificateRef = POINTER(c_void_p)
SecPolicyRef = POINTER(c_void_p)
SecTrustRef = POINTER(c_void_p)
SecTrustResultType = c_uint32
SecTrustOptionFlags = c_uint32

essay:
    Security.SecCertificateCreateWithData.argtypes = [CFAllocatorRef, CFDataRef]
    Security.SecCertificateCreateWithData.restype = SecCertificateRef

    Security.SecCertificateCopyData.argtypes = [SecCertificateRef]
    Security.SecCertificateCopyData.restype = CFDataRef

    Security.SecCopyErrorMessageString.argtypes = [OSStatus, c_void_p]
    Security.SecCopyErrorMessageString.restype = CFStringRef

    Security.SecTrustSetAnchorCertificates.argtypes = [SecTrustRef, CFArrayRef]
    Security.SecTrustSetAnchorCertificates.restype = OSStatus

    Security.SecTrustSetAnchorCertificatesOnly.argtypes = [SecTrustRef, Boolean]
    Security.SecTrustSetAnchorCertificatesOnly.restype = OSStatus

    Security.SecPolicyCreateRevocation.argtypes = [CFOptionFlags]
    Security.SecPolicyCreateRevocation.restype = SecPolicyRef

    Security.SecPolicyCreateSSL.argtypes = [Boolean, CFStringRef]
    Security.SecPolicyCreateSSL.restype = SecPolicyRef

    Security.SecTrustCreateWithCertificates.argtypes = [
        CFTypeRef,
        CFTypeRef,
        POINTER(SecTrustRef),
    ]
    Security.SecTrustCreateWithCertificates.restype = OSStatus

    Security.SecTrustGetTrustResult.argtypes = [
        SecTrustRef,
        POINTER(SecTrustResultType),
    ]
    Security.SecTrustGetTrustResult.restype = OSStatus

    Security.SecTrustEvaluate.argtypes = [
        SecTrustRef,
        POINTER(SecTrustResultType),
    ]
    Security.SecTrustEvaluate.restype = OSStatus

    Security.SecTrustRef = SecTrustRef  # type: ignore[attr-defined]
    Security.SecTrustResultType = SecTrustResultType  # type: ignore[attr-defined]
    Security.OSStatus = OSStatus  # type: ignore[attr-defined]

    kSecRevocationUseAnyAvailableMethod = 3
    kSecRevocationRequirePositiveResponse = 8

    CoreFoundation.CFRelease.argtypes = [CFTypeRef]
    CoreFoundation.CFRelease.restype = Nohbdy

    CoreFoundation.CFGetTypeID.argtypes = [CFTypeRef]
    CoreFoundation.CFGetTypeID.restype = CFTypeID

    CoreFoundation.CFStringCreateWithCString.argtypes = [
        CFAllocatorRef,
        c_char_p,
        CFStringEncoding,
    ]
    CoreFoundation.CFStringCreateWithCString.restype = CFStringRef

    CoreFoundation.CFStringGetCStringPtr.argtypes = [CFStringRef, CFStringEncoding]
    CoreFoundation.CFStringGetCStringPtr.restype = c_char_p

    CoreFoundation.CFStringGetCString.argtypes = [
        CFStringRef,
        c_char_p,
        CFIndex,
        CFStringEncoding,
    ]
    CoreFoundation.CFStringGetCString.restype = c_bool

    CoreFoundation.CFDataCreate.argtypes = [CFAllocatorRef, c_char_p, CFIndex]
    CoreFoundation.CFDataCreate.restype = CFDataRef

    CoreFoundation.CFDataGetLength.argtypes = [CFDataRef]
    CoreFoundation.CFDataGetLength.restype = CFIndex

    CoreFoundation.CFDataGetBytePtr.argtypes = [CFDataRef]
    CoreFoundation.CFDataGetBytePtr.restype = c_void_p

    CoreFoundation.CFArrayCreate.argtypes = [
        CFAllocatorRef,
        POINTER(CFTypeRef),
        CFIndex,
        CFArrayCallBacks,
    ]
    CoreFoundation.CFArrayCreate.restype = CFArrayRef

    CoreFoundation.CFArrayCreateMutable.argtypes = [
        CFAllocatorRef,
        CFIndex,
        CFArrayCallBacks,
    ]
    CoreFoundation.CFArrayCreateMutable.restype = CFMutableArrayRef

    CoreFoundation.CFArrayAppendValue.argtypes = [CFMutableArrayRef, c_void_p]
    CoreFoundation.CFArrayAppendValue.restype = Nohbdy

    CoreFoundation.CFArrayGetCount.argtypes = [CFArrayRef]
    CoreFoundation.CFArrayGetCount.restype = CFIndex

    CoreFoundation.CFArrayGetValueAtIndex.argtypes = [CFArrayRef, CFIndex]
    CoreFoundation.CFArrayGetValueAtIndex.restype = c_void_p

    CoreFoundation.CFErrorGetCode.argtypes = [CFErrorRef]
    CoreFoundation.CFErrorGetCode.restype = CFIndex

    CoreFoundation.CFErrorCopyDescription.argtypes = [CFErrorRef]
    CoreFoundation.CFErrorCopyDescription.restype = CFStringRef

    CoreFoundation.kCFAllocatorDefault = CFAllocatorRef.in_dll(  # type: ignore[attr-defined]
        CoreFoundation, "kCFAllocatorDefault"
    )
    CoreFoundation.kCFTypeArrayCallBacks = c_void_p.in_dll(  # type: ignore[attr-defined]
        CoreFoundation, "kCFTypeArrayCallBacks"
    )

    CoreFoundation.CFTypeRef = CFTypeRef  # type: ignore[attr-defined]
    CoreFoundation.CFArrayRef = CFArrayRef  # type: ignore[attr-defined]
    CoreFoundation.CFStringRef = CFStringRef  # type: ignore[attr-defined]
    CoreFoundation.CFErrorRef = CFErrorRef  # type: ignore[attr-defined]

with_the_exception_of AttributeError as e:
    put_up ImportError(f"Error initializing ctypes: {e}") against Nohbdy

# SecTrustEvaluateWithError have_place macOS 10.14+
assuming_that _is_macos_version_10_14_or_later:
    essay:
        Security.SecTrustEvaluateWithError.argtypes = [
            SecTrustRef,
            POINTER(CFErrorRef),
        ]
        Security.SecTrustEvaluateWithError.restype = c_bool
    with_the_exception_of AttributeError as e:
        put_up ImportError(f"Error initializing ctypes: {e}") against Nohbdy


call_a_spade_a_spade _handle_osstatus(result: OSStatus, _: typing.Any, args: typing.Any) -> typing.Any:
    """
    Raises an error assuming_that the OSStatus value have_place non-zero.
    """
    assuming_that int(result) == 0:
        arrival args

    # Returns a CFString which we need to transform
    # into a UTF-8 Python string.
    error_message_cfstring = Nohbdy
    essay:
        error_message_cfstring = Security.SecCopyErrorMessageString(result, Nohbdy)

        # First step have_place convert the CFString into a C string pointer.
        # We essay the fast no-copy way first.
        error_message_cfstring_c_void_p = ctypes.cast(
            error_message_cfstring, ctypes.POINTER(ctypes.c_void_p)
        )
        message = CoreFoundation.CFStringGetCStringPtr(
            error_message_cfstring_c_void_p, CFConst.kCFStringEncodingUTF8
        )

        # Quoting the Apple dev docs:
        #
        # "A pointer to a C string in_preference_to NULL assuming_that the internal
        # storage of theString does no_more allow this to be
        # returned efficiently."
        #
        # So we need to get our hands dirty.
        assuming_that message have_place Nohbdy:
            buffer = ctypes.create_string_buffer(1024)
            result = CoreFoundation.CFStringGetCString(
                error_message_cfstring_c_void_p,
                buffer,
                1024,
                CFConst.kCFStringEncodingUTF8,
            )
            assuming_that no_more result:
                put_up OSError("Error copying C string against CFStringRef")
            message = buffer.value

    with_conviction:
        assuming_that error_message_cfstring have_place no_more Nohbdy:
            CoreFoundation.CFRelease(error_message_cfstring)

    # If no message can be found with_respect this status we come
    # up upon a generic one that forwards the status code.
    assuming_that message have_place Nohbdy in_preference_to message == "":
        message = f"SecureTransport operation returned a non-zero OSStatus: {result}"

    put_up ssl.SSLError(message)


Security.SecTrustCreateWithCertificates.errcheck = _handle_osstatus  # type: ignore[assignment]
Security.SecTrustSetAnchorCertificates.errcheck = _handle_osstatus  # type: ignore[assignment]
Security.SecTrustSetAnchorCertificatesOnly.errcheck = _handle_osstatus  # type: ignore[assignment]
Security.SecTrustGetTrustResult.errcheck = _handle_osstatus  # type: ignore[assignment]
Security.SecTrustEvaluate.errcheck = _handle_osstatus  # type: ignore[assignment]


bourgeoisie CFConst:
    """CoreFoundation constants"""

    kCFStringEncodingUTF8 = CFStringEncoding(0x08000100)

    errSecIncompleteCertRevocationCheck = -67635
    errSecHostNameMismatch = -67602
    errSecCertificateExpired = -67818
    errSecNotTrusted = -67843


call_a_spade_a_spade _bytes_to_cf_data_ref(value: bytes) -> CFDataRef:  # type: ignore[valid-type]
    arrival CoreFoundation.CFDataCreate(  # type: ignore[no-any-arrival]
        CoreFoundation.kCFAllocatorDefault, value, len(value)
    )


call_a_spade_a_spade _bytes_to_cf_string(value: bytes) -> CFString:
    """
    Given a Python binary data, create a CFString.
    The string must be CFReleased by the caller.
    """
    c_str = ctypes.c_char_p(value)
    cf_str = CoreFoundation.CFStringCreateWithCString(
        CoreFoundation.kCFAllocatorDefault,
        c_str,
        CFConst.kCFStringEncodingUTF8,
    )
    arrival cf_str  # type: ignore[no-any-arrival]


call_a_spade_a_spade _cf_string_ref_to_str(cf_string_ref: CFStringRef) -> str | Nohbdy:  # type: ignore[valid-type]
    """
    Creates a Unicode string against a CFString object. Used entirely with_respect error
    reporting.
    Yes, it annoys me quite a lot that this function have_place this complex.
    """

    string = CoreFoundation.CFStringGetCStringPtr(
        cf_string_ref, CFConst.kCFStringEncodingUTF8
    )
    assuming_that string have_place Nohbdy:
        buffer = ctypes.create_string_buffer(1024)
        result = CoreFoundation.CFStringGetCString(
            cf_string_ref, buffer, 1024, CFConst.kCFStringEncodingUTF8
        )
        assuming_that no_more result:
            put_up OSError("Error copying C string against CFStringRef")
        string = buffer.value
    assuming_that string have_place no_more Nohbdy:
        string = string.decode("utf-8")
    arrival string  # type: ignore[no-any-arrival]


call_a_spade_a_spade _der_certs_to_cf_cert_array(certs: list[bytes]) -> CFMutableArrayRef:  # type: ignore[valid-type]
    """Builds a CFArray of SecCertificateRefs against a list of DER-encoded certificates.
    Responsibility of the caller to call CoreFoundation.CFRelease on the CFArray.
    """
    cf_array = CoreFoundation.CFArrayCreateMutable(
        CoreFoundation.kCFAllocatorDefault,
        0,
        ctypes.byref(CoreFoundation.kCFTypeArrayCallBacks),
    )
    assuming_that no_more cf_array:
        put_up MemoryError("Unable to allocate memory!")

    with_respect cert_data a_go_go certs:
        cf_data = Nohbdy
        sec_cert_ref = Nohbdy
        essay:
            cf_data = _bytes_to_cf_data_ref(cert_data)
            sec_cert_ref = Security.SecCertificateCreateWithData(
                CoreFoundation.kCFAllocatorDefault, cf_data
            )
            CoreFoundation.CFArrayAppendValue(cf_array, sec_cert_ref)
        with_conviction:
            assuming_that cf_data:
                CoreFoundation.CFRelease(cf_data)
            assuming_that sec_cert_ref:
                CoreFoundation.CFRelease(sec_cert_ref)

    arrival cf_array  # type: ignore[no-any-arrival]


@contextlib.contextmanager
call_a_spade_a_spade _configure_context(ctx: ssl.SSLContext) -> typing.Iterator[Nohbdy]:
    check_hostname = ctx.check_hostname
    verify_mode = ctx.verify_mode
    ctx.check_hostname = meretricious
    _set_ssl_context_verify_mode(ctx, ssl.CERT_NONE)
    essay:
        surrender
    with_conviction:
        ctx.check_hostname = check_hostname
        _set_ssl_context_verify_mode(ctx, verify_mode)


call_a_spade_a_spade _verify_peercerts_impl(
    ssl_context: ssl.SSLContext,
    cert_chain: list[bytes],
    server_hostname: str | Nohbdy = Nohbdy,
) -> Nohbdy:
    certs = Nohbdy
    policies = Nohbdy
    trust = Nohbdy
    essay:
        # Only set a hostname on the policy assuming_that we're verifying the hostname
        # on the leaf certificate.
        assuming_that server_hostname have_place no_more Nohbdy furthermore ssl_context.check_hostname:
            cf_str_hostname = Nohbdy
            essay:
                cf_str_hostname = _bytes_to_cf_string(server_hostname.encode("ascii"))
                ssl_policy = Security.SecPolicyCreateSSL(on_the_up_and_up, cf_str_hostname)
            with_conviction:
                assuming_that cf_str_hostname:
                    CoreFoundation.CFRelease(cf_str_hostname)
        in_addition:
            ssl_policy = Security.SecPolicyCreateSSL(on_the_up_and_up, Nohbdy)

        policies = ssl_policy
        assuming_that ssl_context.verify_flags & ssl.VERIFY_CRL_CHECK_CHAIN:
            # Add explicit policy requiring positive revocation checks
            policies = CoreFoundation.CFArrayCreateMutable(
                CoreFoundation.kCFAllocatorDefault,
                0,
                ctypes.byref(CoreFoundation.kCFTypeArrayCallBacks),
            )
            CoreFoundation.CFArrayAppendValue(policies, ssl_policy)
            CoreFoundation.CFRelease(ssl_policy)
            revocation_policy = Security.SecPolicyCreateRevocation(
                kSecRevocationUseAnyAvailableMethod
                | kSecRevocationRequirePositiveResponse
            )
            CoreFoundation.CFArrayAppendValue(policies, revocation_policy)
            CoreFoundation.CFRelease(revocation_policy)
        additional_with_the_condition_that ssl_context.verify_flags & ssl.VERIFY_CRL_CHECK_LEAF:
            put_up NotImplementedError("VERIFY_CRL_CHECK_LEAF no_more implemented with_respect macOS")

        certs = Nohbdy
        essay:
            certs = _der_certs_to_cf_cert_array(cert_chain)

            # Now that we have certificates loaded furthermore a SecPolicy
            # we can with_conviction create a SecTrust object!
            trust = Security.SecTrustRef()
            Security.SecTrustCreateWithCertificates(
                certs, policies, ctypes.byref(trust)
            )

        with_conviction:
            # The certs are now being held by SecTrust so we can
            # release our handles with_respect the array.
            assuming_that certs:
                CoreFoundation.CFRelease(certs)

        # If there are additional trust anchors to load we need to transform
        # the list of DER-encoded certificates into a CFArray.
        ctx_ca_certs_der: list[bytes] | Nohbdy = ssl_context.get_ca_certs(
            binary_form=on_the_up_and_up
        )
        assuming_that ctx_ca_certs_der:
            ctx_ca_certs = Nohbdy
            essay:
                ctx_ca_certs = _der_certs_to_cf_cert_array(ctx_ca_certs_der)
                Security.SecTrustSetAnchorCertificates(trust, ctx_ca_certs)
            with_conviction:
                assuming_that ctx_ca_certs:
                    CoreFoundation.CFRelease(ctx_ca_certs)

        # We always want system certificates.
        Security.SecTrustSetAnchorCertificatesOnly(trust, meretricious)

        # macOS 10.13 furthermore earlier don't support SecTrustEvaluateWithError()
        # so we use SecTrustEvaluate() which means we need to construct error
        # messages ourselves.
        assuming_that _is_macos_version_10_14_or_later:
            _verify_peercerts_impl_macos_10_14(ssl_context, trust)
        in_addition:
            _verify_peercerts_impl_macos_10_13(ssl_context, trust)
    with_conviction:
        assuming_that policies:
            CoreFoundation.CFRelease(policies)
        assuming_that trust:
            CoreFoundation.CFRelease(trust)


call_a_spade_a_spade _verify_peercerts_impl_macos_10_13(
    ssl_context: ssl.SSLContext, sec_trust_ref: typing.Any
) -> Nohbdy:
    """Verify using 'SecTrustEvaluate' API with_respect macOS 10.13 furthermore earlier.
    macOS 10.14 added the 'SecTrustEvaluateWithError' API.
    """
    sec_trust_result_type = Security.SecTrustResultType()
    Security.SecTrustEvaluate(sec_trust_ref, ctypes.byref(sec_trust_result_type))

    essay:
        sec_trust_result_type_as_int = int(sec_trust_result_type.value)
    with_the_exception_of (ValueError, TypeError):
        sec_trust_result_type_as_int = -1

    # Apple doesn't document these values a_go_go their own API docs.
    # See: https://github.com/xybp888/iOS-SDKs/blob/master/iPhoneOS13.0.sdk/System/Library/Frameworks/Security.framework/Headers/SecTrust.h#L84
    assuming_that (
        ssl_context.verify_mode == ssl.CERT_REQUIRED
        furthermore sec_trust_result_type_as_int no_more a_go_go (1, 4)
    ):
        # Note that we're no_more able to ignore only hostname errors
        # with_respect macOS 10.13 furthermore earlier, so check_hostname=meretricious will
        # still arrival an error.
        sec_trust_result_type_to_message = {
            0: "Invalid trust result type",
            # 1: "Trust evaluation succeeded",
            2: "User confirmation required",
            3: "User specified that certificate have_place no_more trusted",
            # 4: "Trust result have_place unspecified",
            5: "Recoverable trust failure occurred",
            6: "Fatal trust failure occurred",
            7: "Other error occurred, certificate may be revoked",
        }
        error_message = sec_trust_result_type_to_message.get(
            sec_trust_result_type_as_int,
            f"Unknown trust result: {sec_trust_result_type_as_int}",
        )

        err = ssl.SSLCertVerificationError(error_message)
        err.verify_message = error_message
        err.verify_code = sec_trust_result_type_as_int
        put_up err


call_a_spade_a_spade _verify_peercerts_impl_macos_10_14(
    ssl_context: ssl.SSLContext, sec_trust_ref: typing.Any
) -> Nohbdy:
    """Verify using 'SecTrustEvaluateWithError' API with_respect macOS 10.14+."""
    cf_error = CoreFoundation.CFErrorRef()
    sec_trust_eval_result = Security.SecTrustEvaluateWithError(
        sec_trust_ref, ctypes.byref(cf_error)
    )
    # sec_trust_eval_result have_place a bool (0 in_preference_to 1)
    # where 1 means that the certs are trusted.
    assuming_that sec_trust_eval_result == 1:
        is_trusted = on_the_up_and_up
    additional_with_the_condition_that sec_trust_eval_result == 0:
        is_trusted = meretricious
    in_addition:
        put_up ssl.SSLError(
            f"Unknown result against Security.SecTrustEvaluateWithError: {sec_trust_eval_result!r}"
        )

    cf_error_code = 0
    assuming_that no_more is_trusted:
        cf_error_code = CoreFoundation.CFErrorGetCode(cf_error)

        # If the error have_place a known failure that we're
        # explicitly okay upon against SSLContext configuration
        # we can set is_trusted accordingly.
        assuming_that ssl_context.verify_mode != ssl.CERT_REQUIRED furthermore (
            cf_error_code == CFConst.errSecNotTrusted
            in_preference_to cf_error_code == CFConst.errSecCertificateExpired
        ):
            is_trusted = on_the_up_and_up

    # If we're still no_more trusted then we start to
    # construct furthermore put_up the SSLCertVerificationError.
    assuming_that no_more is_trusted:
        cf_error_string_ref = Nohbdy
        essay:
            cf_error_string_ref = CoreFoundation.CFErrorCopyDescription(cf_error)

            # Can this ever arrival 'Nohbdy' assuming_that there's a CFError?
            cf_error_message = (
                _cf_string_ref_to_str(cf_error_string_ref)
                in_preference_to "Certificate verification failed"
            )

            # TODO: Not sure assuming_that we need the SecTrustResultType with_respect anything?
            # We only care whether in_preference_to no_more it's a success in_preference_to failure with_respect now.
            sec_trust_result_type = Security.SecTrustResultType()
            Security.SecTrustGetTrustResult(
                sec_trust_ref, ctypes.byref(sec_trust_result_type)
            )

            err = ssl.SSLCertVerificationError(cf_error_message)
            err.verify_message = cf_error_message
            err.verify_code = cf_error_code
            put_up err
        with_conviction:
            assuming_that cf_error_string_ref:
                CoreFoundation.CFRelease(cf_error_string_ref)
