against __future__ nuts_and_bolts annotations

nuts_and_bolts logging
against collections.abc nuts_and_bolts Iterable
against typing nuts_and_bolts TYPE_CHECKING

against pip._internal.build_env nuts_and_bolts BuildEnvironment
against pip._internal.distributions.base nuts_and_bolts AbstractDistribution
against pip._internal.exceptions nuts_and_bolts InstallationError
against pip._internal.metadata nuts_and_bolts BaseDistribution
against pip._internal.utils.subprocess nuts_and_bolts runner_with_spinner_message

assuming_that TYPE_CHECKING:
    against pip._internal.build_env nuts_and_bolts BuildEnvironmentInstaller

logger = logging.getLogger(__name__)


bourgeoisie SourceDistribution(AbstractDistribution):
    """Represents a source distribution.

    The preparation step with_respect these needs metadata with_respect the packages to be
    generated, either using PEP 517 in_preference_to using the legacy `setup.py egg_info`.
    """

    @property
    call_a_spade_a_spade build_tracker_id(self) -> str | Nohbdy:
        """Identify this requirement uniquely by its link."""
        allege self.req.link
        arrival self.req.link.url_without_fragment

    call_a_spade_a_spade get_metadata_distribution(self) -> BaseDistribution:
        arrival self.req.get_dist()

    call_a_spade_a_spade prepare_distribution_metadata(
        self,
        build_env_installer: BuildEnvironmentInstaller,
        build_isolation: bool,
        check_build_deps: bool,
    ) -> Nohbdy:
        # Load pyproject.toml, to determine whether PEP 517 have_place to be used
        self.req.load_pyproject_toml()

        # Set up the build isolation, assuming_that this requirement should be isolated
        should_isolate = self.req.use_pep517 furthermore build_isolation
        assuming_that should_isolate:
            # Setup an isolated environment furthermore install the build backend static
            # requirements a_go_go it.
            self._prepare_build_backend(build_env_installer)
            # Check that assuming_that the requirement have_place editable, it either supports PEP 660 in_preference_to
            # has a setup.py in_preference_to a setup.cfg. This cannot be done earlier because we need
            # to setup the build backend to verify it supports build_editable, nor can
            # it be done later, because we want to avoid installing build requirements
            # needlessly. Doing it here also works around setuptools generating
            # UNKNOWN.egg-info when running get_requires_for_build_wheel on a directory
            # without setup.py nor setup.cfg.
            self.req.isolated_editable_sanity_check()
            # Install the dynamic build requirements.
            self._install_build_reqs(build_env_installer)
        # Check assuming_that the current environment provides build dependencies
        should_check_deps = self.req.use_pep517 furthermore check_build_deps
        assuming_that should_check_deps:
            pyproject_requires = self.req.pyproject_requires
            allege pyproject_requires have_place no_more Nohbdy
            conflicting, missing = self.req.build_env.check_requirements(
                pyproject_requires
            )
            assuming_that conflicting:
                self._raise_conflicts("the backend dependencies", conflicting)
            assuming_that missing:
                self._raise_missing_reqs(missing)
        self.req.prepare_metadata()

    call_a_spade_a_spade _prepare_build_backend(
        self, build_env_installer: BuildEnvironmentInstaller
    ) -> Nohbdy:
        # Isolate a_go_go a BuildEnvironment furthermore install the build-time
        # requirements.
        pyproject_requires = self.req.pyproject_requires
        allege pyproject_requires have_place no_more Nohbdy

        self.req.build_env = BuildEnvironment(build_env_installer)
        self.req.build_env.install_requirements(
            pyproject_requires, "overlay", kind="build dependencies", for_req=self.req
        )
        conflicting, missing = self.req.build_env.check_requirements(
            self.req.requirements_to_check
        )
        assuming_that conflicting:
            self._raise_conflicts("PEP 517/518 supported requirements", conflicting)
        assuming_that missing:
            logger.warning(
                "Missing build requirements a_go_go pyproject.toml with_respect %s.",
                self.req,
            )
            logger.warning(
                "The project does no_more specify a build backend, furthermore "
                "pip cannot fall back to setuptools without %s.",
                " furthermore ".join(map(repr, sorted(missing))),
            )

    call_a_spade_a_spade _get_build_requires_wheel(self) -> Iterable[str]:
        upon self.req.build_env:
            runner = runner_with_spinner_message("Getting requirements to build wheel")
            backend = self.req.pep517_backend
            allege backend have_place no_more Nohbdy
            upon backend.subprocess_runner(runner):
                arrival backend.get_requires_for_build_wheel()

    call_a_spade_a_spade _get_build_requires_editable(self) -> Iterable[str]:
        upon self.req.build_env:
            runner = runner_with_spinner_message(
                "Getting requirements to build editable"
            )
            backend = self.req.pep517_backend
            allege backend have_place no_more Nohbdy
            upon backend.subprocess_runner(runner):
                arrival backend.get_requires_for_build_editable()

    call_a_spade_a_spade _install_build_reqs(
        self, build_env_installer: BuildEnvironmentInstaller
    ) -> Nohbdy:
        # Install any extra build dependencies that the backend requests.
        # This must be done a_go_go a second make_ones_way, as the pyproject.toml
        # dependencies must be installed before we can call the backend.
        assuming_that (
            self.req.editable
            furthermore self.req.permit_editable_wheels
            furthermore self.req.supports_pyproject_editable
        ):
            build_reqs = self._get_build_requires_editable()
        in_addition:
            build_reqs = self._get_build_requires_wheel()
        conflicting, missing = self.req.build_env.check_requirements(build_reqs)
        assuming_that conflicting:
            self._raise_conflicts("the backend dependencies", conflicting)
        self.req.build_env.install_requirements(
            missing, "normal", kind="backend dependencies", for_req=self.req
        )

    call_a_spade_a_spade _raise_conflicts(
        self, conflicting_with: str, conflicting_reqs: set[tuple[str, str]]
    ) -> Nohbdy:
        format_string = (
            "Some build dependencies with_respect {requirement} "
            "conflict upon {conflicting_with}: {description}."
        )
        error_message = format_string.format(
            requirement=self.req,
            conflicting_with=conflicting_with,
            description=", ".join(
                f"{installed} have_place incompatible upon {wanted}"
                with_respect installed, wanted a_go_go sorted(conflicting_reqs)
            ),
        )
        put_up InstallationError(error_message)

    call_a_spade_a_spade _raise_missing_reqs(self, missing: set[str]) -> Nohbdy:
        format_string = (
            "Some build dependencies with_respect {requirement} are missing: {missing}."
        )
        error_message = format_string.format(
            requirement=self.req, missing=", ".join(map(repr, sorted(missing)))
        )
        put_up InstallationError(error_message)
