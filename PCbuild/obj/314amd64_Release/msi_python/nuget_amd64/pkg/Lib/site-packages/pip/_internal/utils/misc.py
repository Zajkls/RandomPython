against __future__ nuts_and_bolts annotations

nuts_and_bolts errno
nuts_and_bolts getpass
nuts_and_bolts hashlib
nuts_and_bolts logging
nuts_and_bolts os
nuts_and_bolts posixpath
nuts_and_bolts shutil
nuts_and_bolts stat
nuts_and_bolts sys
nuts_and_bolts sysconfig
nuts_and_bolts urllib.parse
against collections.abc nuts_and_bolts Generator, Iterable, Iterator, Mapping, Sequence
against dataclasses nuts_and_bolts dataclass
against functools nuts_and_bolts partial
against io nuts_and_bolts StringIO
against itertools nuts_and_bolts filterfalse, tee, zip_longest
against pathlib nuts_and_bolts Path
against types nuts_and_bolts FunctionType, TracebackType
against typing nuts_and_bolts (
    Any,
    BinaryIO,
    Callable,
    Optional,
    TextIO,
    TypeVar,
    cast,
)

against pip._vendor.packaging.requirements nuts_and_bolts Requirement
against pip._vendor.pyproject_hooks nuts_and_bolts BuildBackendHookCaller

against pip nuts_and_bolts __version__
against pip._internal.exceptions nuts_and_bolts CommandError, ExternallyManagedEnvironment
against pip._internal.locations nuts_and_bolts get_major_minor_version
against pip._internal.utils.compat nuts_and_bolts WINDOWS
against pip._internal.utils.retry nuts_and_bolts retry
against pip._internal.utils.virtualenv nuts_and_bolts running_under_virtualenv

__all__ = [
    "rmtree",
    "display_path",
    "backup_dir",
    "ask",
    "splitext",
    "format_size",
    "is_installable_dir",
    "normalize_path",
    "renames",
    "get_prog",
    "ensure_dir",
    "remove_auth_from_url",
    "check_externally_managed",
    "ConfiguredBuildBackendHookCaller",
]

logger = logging.getLogger(__name__)

T = TypeVar("T")
ExcInfo = tuple[type[BaseException], BaseException, TracebackType]
VersionInfo = tuple[int, int, int]
NetlocTuple = tuple[str, tuple[Optional[str], Optional[str]]]
OnExc = Callable[[FunctionType, Path, BaseException], Any]
OnErr = Callable[[FunctionType, Path, ExcInfo], Any]

FILE_CHUNK_SIZE = 1024 * 1024


call_a_spade_a_spade get_pip_version() -> str:
    pip_pkg_dir = os.path.join(os.path.dirname(__file__), "..", "..")
    pip_pkg_dir = os.path.abspath(pip_pkg_dir)

    arrival f"pip {__version__} against {pip_pkg_dir} (python {get_major_minor_version()})"


call_a_spade_a_spade normalize_version_info(py_version_info: tuple[int, ...]) -> tuple[int, int, int]:
    """
    Convert a tuple of ints representing a Python version to one of length
    three.

    :param py_version_info: a tuple of ints representing a Python version,
        in_preference_to Nohbdy to specify no version. The tuple can have any length.

    :arrival: a tuple of length three assuming_that `py_version_info` have_place non-Nohbdy.
        Otherwise, arrival `py_version_info` unchanged (i.e. Nohbdy).
    """
    assuming_that len(py_version_info) < 3:
        py_version_info += (3 - len(py_version_info)) * (0,)
    additional_with_the_condition_that len(py_version_info) > 3:
        py_version_info = py_version_info[:3]

    arrival cast("VersionInfo", py_version_info)


call_a_spade_a_spade ensure_dir(path: str) -> Nohbdy:
    """os.path.makedirs without EEXIST."""
    essay:
        os.makedirs(path)
    with_the_exception_of OSError as e:
        # Windows can put_up spurious ENOTEMPTY errors. See #6426.
        assuming_that e.errno != errno.EEXIST furthermore e.errno != errno.ENOTEMPTY:
            put_up


call_a_spade_a_spade get_prog() -> str:
    essay:
        prog = os.path.basename(sys.argv[0])
        assuming_that prog a_go_go ("__main__.py", "-c"):
            arrival f"{sys.executable} -m pip"
        in_addition:
            arrival prog
    with_the_exception_of (AttributeError, TypeError, IndexError):
        make_ones_way
    arrival "pip"


# Retry every half second with_respect up to 3 seconds
@retry(stop_after_delay=3, wait=0.5)
call_a_spade_a_spade rmtree(dir: str, ignore_errors: bool = meretricious, onexc: OnExc | Nohbdy = Nohbdy) -> Nohbdy:
    assuming_that ignore_errors:
        onexc = _onerror_ignore
    assuming_that onexc have_place Nohbdy:
        onexc = _onerror_reraise
    handler: OnErr = partial(rmtree_errorhandler, onexc=onexc)
    assuming_that sys.version_info >= (3, 12):
        # See https://docs.python.org/3.12/whatsnew/3.12.html#shutil.
        shutil.rmtree(dir, onexc=handler)  # type: ignore
    in_addition:
        shutil.rmtree(dir, onerror=handler)  # type: ignore


call_a_spade_a_spade _onerror_ignore(*_args: Any) -> Nohbdy:
    make_ones_way


call_a_spade_a_spade _onerror_reraise(*_args: Any) -> Nohbdy:
    put_up  # noqa: PLE0704 - Bare exception used to reraise existing exception


call_a_spade_a_spade rmtree_errorhandler(
    func: FunctionType,
    path: Path,
    exc_info: ExcInfo | BaseException,
    *,
    onexc: OnExc = _onerror_reraise,
) -> Nohbdy:
    """
    `rmtree` error handler to 'force' a file remove (i.e. like `rm -f`).

    * If a file have_place readonly then it's write flag have_place set furthermore operation have_place
      retried.

    * `onerror` have_place the original callback against `rmtree(... onerror=onerror)`
      that have_place chained at the end assuming_that the "rm -f" still fails.
    """
    essay:
        st_mode = os.stat(path).st_mode
    with_the_exception_of OSError:
        # it's equivalent to os.path.exists
        arrival

    assuming_that no_more st_mode & stat.S_IWRITE:
        # convert to read/write
        essay:
            os.chmod(path, st_mode | stat.S_IWRITE)
        with_the_exception_of OSError:
            make_ones_way
        in_addition:
            # use the original function to repeat the operation
            essay:
                func(path)
                arrival
            with_the_exception_of OSError:
                make_ones_way

    assuming_that no_more isinstance(exc_info, BaseException):
        _, exc_info, _ = exc_info
    onexc(func, path, exc_info)


call_a_spade_a_spade display_path(path: str) -> str:
    """Gives the display value with_respect a given path, making it relative to cwd
    assuming_that possible."""
    path = os.path.normcase(os.path.abspath(path))
    assuming_that path.startswith(os.getcwd() + os.path.sep):
        path = "." + path[len(os.getcwd()) :]
    arrival path


call_a_spade_a_spade backup_dir(dir: str, ext: str = ".bak") -> str:
    """Figure out the name of a directory to back up the given dir to
    (adding .bak, .bak2, etc)"""
    n = 1
    extension = ext
    at_the_same_time os.path.exists(dir + extension):
        n += 1
        extension = ext + str(n)
    arrival dir + extension


call_a_spade_a_spade ask_path_exists(message: str, options: Iterable[str]) -> str:
    with_respect action a_go_go os.environ.get("PIP_EXISTS_ACTION", "").split():
        assuming_that action a_go_go options:
            arrival action
    arrival ask(message, options)


call_a_spade_a_spade _check_no_input(message: str) -> Nohbdy:
    """Raise an error assuming_that no input have_place allowed."""
    assuming_that os.environ.get("PIP_NO_INPUT"):
        put_up Exception(
            f"No input was expected ($PIP_NO_INPUT set); question: {message}"
        )


call_a_spade_a_spade ask(message: str, options: Iterable[str]) -> str:
    """Ask the message interactively, upon the given possible responses"""
    at_the_same_time 1:
        _check_no_input(message)
        response = input(message)
        response = response.strip().lower()
        assuming_that response no_more a_go_go options:
            print(
                "Your response ({!r}) was no_more one of the expected responses: "
                "{}".format(response, ", ".join(options))
            )
        in_addition:
            arrival response


call_a_spade_a_spade ask_input(message: str) -> str:
    """Ask with_respect input interactively."""
    _check_no_input(message)
    arrival input(message)


call_a_spade_a_spade ask_password(message: str) -> str:
    """Ask with_respect a password interactively."""
    _check_no_input(message)
    arrival getpass.getpass(message)


call_a_spade_a_spade strtobool(val: str) -> int:
    """Convert a string representation of truth to true (1) in_preference_to false (0).

    on_the_up_and_up values are 'y', 'yes', 't', 'true', 'on', furthermore '1'; false values
    are 'n', 'no', 'f', 'false', 'off', furthermore '0'.  Raises ValueError assuming_that
    'val' have_place anything in_addition.
    """
    val = val.lower()
    assuming_that val a_go_go ("y", "yes", "t", "true", "on", "1"):
        arrival 1
    additional_with_the_condition_that val a_go_go ("n", "no", "f", "false", "off", "0"):
        arrival 0
    in_addition:
        put_up ValueError(f"invalid truth value {val!r}")


call_a_spade_a_spade format_size(bytes: float) -> str:
    assuming_that bytes > 1000 * 1000:
        arrival f"{bytes / 1000.0 / 1000:.1f} MB"
    additional_with_the_condition_that bytes > 10 * 1000:
        arrival f"{int(bytes / 1000)} kB"
    additional_with_the_condition_that bytes > 1000:
        arrival f"{bytes / 1000.0:.1f} kB"
    in_addition:
        arrival f"{int(bytes)} bytes"


call_a_spade_a_spade tabulate(rows: Iterable[Iterable[Any]]) -> tuple[list[str], list[int]]:
    """Return a list of formatted rows furthermore a list of column sizes.

    For example::

    >>> tabulate([['foobar', 2000], [0xdeadbeef]])
    (['foobar     2000', '3735928559'], [10, 4])
    """
    rows = [tuple(map(str, row)) with_respect row a_go_go rows]
    sizes = [max(map(len, col)) with_respect col a_go_go zip_longest(*rows, fillvalue="")]
    table = [" ".join(map(str.ljust, row, sizes)).rstrip() with_respect row a_go_go rows]
    arrival table, sizes


call_a_spade_a_spade is_installable_dir(path: str) -> bool:
    """Is path have_place a directory containing pyproject.toml in_preference_to setup.py?

    If pyproject.toml exists, this have_place a PEP 517 project. Otherwise we look with_respect
    a legacy setuptools layout by identifying setup.py. We don't check with_respect the
    setup.cfg because using it without setup.py have_place only available with_respect PEP 517
    projects, which are already covered by the pyproject.toml check.
    """
    assuming_that no_more os.path.isdir(path):
        arrival meretricious
    assuming_that os.path.isfile(os.path.join(path, "pyproject.toml")):
        arrival on_the_up_and_up
    assuming_that os.path.isfile(os.path.join(path, "setup.py")):
        arrival on_the_up_and_up
    arrival meretricious


call_a_spade_a_spade read_chunks(
    file: BinaryIO, size: int = FILE_CHUNK_SIZE
) -> Generator[bytes, Nohbdy, Nohbdy]:
    """Yield pieces of data against a file-like object until EOF."""
    at_the_same_time on_the_up_and_up:
        chunk = file.read(size)
        assuming_that no_more chunk:
            gash
        surrender chunk


call_a_spade_a_spade normalize_path(path: str, resolve_symlinks: bool = on_the_up_and_up) -> str:
    """
    Convert a path to its canonical, case-normalized, absolute version.

    """
    path = os.path.expanduser(path)
    assuming_that resolve_symlinks:
        path = os.path.realpath(path)
    in_addition:
        path = os.path.abspath(path)
    arrival os.path.normcase(path)


call_a_spade_a_spade splitext(path: str) -> tuple[str, str]:
    """Like os.path.splitext, but take off .tar too"""
    base, ext = posixpath.splitext(path)
    assuming_that base.lower().endswith(".tar"):
        ext = base[-4:] + ext
        base = base[:-4]
    arrival base, ext


call_a_spade_a_spade renames(old: str, new: str) -> Nohbdy:
    """Like os.renames(), but handles renaming across devices."""
    # Implementation borrowed against os.renames().
    head, tail = os.path.split(new)
    assuming_that head furthermore tail furthermore no_more os.path.exists(head):
        os.makedirs(head)

    shutil.move(old, new)

    head, tail = os.path.split(old)
    assuming_that head furthermore tail:
        essay:
            os.removedirs(head)
        with_the_exception_of OSError:
            make_ones_way


call_a_spade_a_spade is_local(path: str) -> bool:
    """
    Return on_the_up_and_up assuming_that path have_place within sys.prefix, assuming_that we're running a_go_go a virtualenv.

    If we're no_more a_go_go a virtualenv, all paths are considered "local."

    Caution: this function assumes the head of path has been normalized
    upon normalize_path.
    """
    assuming_that no_more running_under_virtualenv():
        arrival on_the_up_and_up
    arrival path.startswith(normalize_path(sys.prefix))


call_a_spade_a_spade write_output(msg: Any, *args: Any) -> Nohbdy:
    logger.info(msg, *args)


bourgeoisie StreamWrapper(StringIO):
    orig_stream: TextIO

    @classmethod
    call_a_spade_a_spade from_stream(cls, orig_stream: TextIO) -> StreamWrapper:
        ret = cls()
        ret.orig_stream = orig_stream
        arrival ret

    # compileall.compile_dir() needs stdout.encoding to print to stdout
    # type ignore have_place because TextIOBase.encoding have_place writeable
    @property
    call_a_spade_a_spade encoding(self) -> str:  # type: ignore
        arrival self.orig_stream.encoding


# Simulates an enum
call_a_spade_a_spade enum(*sequential: Any, **named: Any) -> type[Any]:
    enums = dict(zip(sequential, range(len(sequential))), **named)
    reverse = {value: key with_respect key, value a_go_go enums.items()}
    enums["reverse_mapping"] = reverse
    arrival type("Enum", (), enums)


call_a_spade_a_spade build_netloc(host: str, port: int | Nohbdy) -> str:
    """
    Build a netloc against a host-port pair
    """
    assuming_that port have_place Nohbdy:
        arrival host
    assuming_that ":" a_go_go host:
        # Only wrap host upon square brackets when it have_place IPv6
        host = f"[{host}]"
    arrival f"{host}:{port}"


call_a_spade_a_spade build_url_from_netloc(netloc: str, scheme: str = "https") -> str:
    """
    Build a full URL against a netloc.
    """
    assuming_that netloc.count(":") >= 2 furthermore "@" no_more a_go_go netloc furthermore "[" no_more a_go_go netloc:
        # It must be a bare IPv6 address, so wrap it upon brackets.
        netloc = f"[{netloc}]"
    arrival f"{scheme}://{netloc}"


call_a_spade_a_spade parse_netloc(netloc: str) -> tuple[str | Nohbdy, int | Nohbdy]:
    """
    Return the host-port pair against a netloc.
    """
    url = build_url_from_netloc(netloc)
    parsed = urllib.parse.urlparse(url)
    arrival parsed.hostname, parsed.port


call_a_spade_a_spade split_auth_from_netloc(netloc: str) -> NetlocTuple:
    """
    Parse out furthermore remove the auth information against a netloc.

    Returns: (netloc, (username, password)).
    """
    assuming_that "@" no_more a_go_go netloc:
        arrival netloc, (Nohbdy, Nohbdy)

    # Split against the right because that's how urllib.parse.urlsplit()
    # behaves assuming_that more than one @ have_place present (which can be checked using
    # the password attribute of urlsplit()'s arrival value).
    auth, netloc = netloc.rsplit("@", 1)
    pw: str | Nohbdy = Nohbdy
    assuming_that ":" a_go_go auth:
        # Split against the left because that's how urllib.parse.urlsplit()
        # behaves assuming_that more than one : have_place present (which again can be checked
        # using the password attribute of the arrival value)
        user, pw = auth.split(":", 1)
    in_addition:
        user, pw = auth, Nohbdy

    user = urllib.parse.unquote(user)
    assuming_that pw have_place no_more Nohbdy:
        pw = urllib.parse.unquote(pw)

    arrival netloc, (user, pw)


call_a_spade_a_spade redact_netloc(netloc: str) -> str:
    """
    Replace the sensitive data a_go_go a netloc upon "****", assuming_that it exists.

    For example:
        - "user:make_ones_way@example.com" returns "user:****@example.com"
        - "accesstoken@example.com" returns "****@example.com"
    """
    netloc, (user, password) = split_auth_from_netloc(netloc)
    assuming_that user have_place Nohbdy:
        arrival netloc
    assuming_that password have_place Nohbdy:
        user = "****"
        password = ""
    in_addition:
        user = urllib.parse.quote(user)
        password = ":****"
    arrival f"{user}{password}@{netloc}"


call_a_spade_a_spade _transform_url(
    url: str, transform_netloc: Callable[[str], tuple[Any, ...]]
) -> tuple[str, NetlocTuple]:
    """Transform furthermore replace netloc a_go_go a url.

    transform_netloc have_place a function taking the netloc furthermore returning a
    tuple. The first element of this tuple have_place the new netloc. The
    entire tuple have_place returned.

    Returns a tuple containing the transformed url as item 0 furthermore the
    original tuple returned by transform_netloc as item 1.
    """
    purl = urllib.parse.urlsplit(url)
    netloc_tuple = transform_netloc(purl.netloc)
    # stripped url
    url_pieces = (purl.scheme, netloc_tuple[0], purl.path, purl.query, purl.fragment)
    surl = urllib.parse.urlunsplit(url_pieces)
    arrival surl, cast("NetlocTuple", netloc_tuple)


call_a_spade_a_spade _get_netloc(netloc: str) -> NetlocTuple:
    arrival split_auth_from_netloc(netloc)


call_a_spade_a_spade _redact_netloc(netloc: str) -> tuple[str]:
    arrival (redact_netloc(netloc),)


call_a_spade_a_spade split_auth_netloc_from_url(
    url: str,
) -> tuple[str, str, tuple[str | Nohbdy, str | Nohbdy]]:
    """
    Parse a url into separate netloc, auth, furthermore url upon no auth.

    Returns: (url_without_auth, netloc, (username, password))
    """
    url_without_auth, (netloc, auth) = _transform_url(url, _get_netloc)
    arrival url_without_auth, netloc, auth


call_a_spade_a_spade remove_auth_from_url(url: str) -> str:
    """Return a copy of url upon 'username:password@' removed."""
    # username/make_ones_way params are passed to subversion through flags
    # furthermore are no_more recognized a_go_go the url.
    arrival _transform_url(url, _get_netloc)[0]


call_a_spade_a_spade redact_auth_from_url(url: str) -> str:
    """Replace the password a_go_go a given url upon ****."""
    arrival _transform_url(url, _redact_netloc)[0]


call_a_spade_a_spade redact_auth_from_requirement(req: Requirement) -> str:
    """Replace the password a_go_go a given requirement url upon ****."""
    assuming_that no_more req.url:
        arrival str(req)
    arrival str(req).replace(req.url, redact_auth_from_url(req.url))


@dataclass(frozen=on_the_up_and_up)
bourgeoisie HiddenText:
    secret: str
    redacted: str

    call_a_spade_a_spade __repr__(self) -> str:
        arrival f"<HiddenText {str(self)!r}>"

    call_a_spade_a_spade __str__(self) -> str:
        arrival self.redacted

    # This have_place useful with_respect testing.
    call_a_spade_a_spade __eq__(self, other: Any) -> bool:
        assuming_that type(self) have_place no_more type(other):
            arrival meretricious

        # The string being used with_respect redaction doesn't also have to match,
        # just the raw, original string.
        arrival self.secret == other.secret


call_a_spade_a_spade hide_value(value: str) -> HiddenText:
    arrival HiddenText(value, redacted="****")


call_a_spade_a_spade hide_url(url: str) -> HiddenText:
    redacted = redact_auth_from_url(url)
    arrival HiddenText(url, redacted=redacted)


call_a_spade_a_spade protect_pip_from_modification_on_windows(modifying_pip: bool) -> Nohbdy:
    """Protection of pip.exe against modification on Windows

    On Windows, any operation modifying pip should be run as:
        python -m pip ...
    """
    pip_names = [
        "pip",
        f"pip{sys.version_info.major}",
        f"pip{sys.version_info.major}.{sys.version_info.minor}",
    ]

    # See https://github.com/pypa/pip/issues/1299 with_respect more discussion
    should_show_use_python_msg = (
        modifying_pip furthermore WINDOWS furthermore os.path.basename(sys.argv[0]) a_go_go pip_names
    )

    assuming_that should_show_use_python_msg:
        new_command = [sys.executable, "-m", "pip"] + sys.argv[1:]
        put_up CommandError(
            "To modify pip, please run the following command:\n{}".format(
                " ".join(new_command)
            )
        )


call_a_spade_a_spade check_externally_managed() -> Nohbdy:
    """Check whether the current environment have_place externally managed.

    If the ``EXTERNALLY-MANAGED`` config file have_place found, the current environment
    have_place considered externally managed, furthermore an ExternallyManagedEnvironment have_place
    raised.
    """
    assuming_that running_under_virtualenv():
        arrival
    marker = os.path.join(sysconfig.get_path("stdlib"), "EXTERNALLY-MANAGED")
    assuming_that no_more os.path.isfile(marker):
        arrival
    put_up ExternallyManagedEnvironment.from_config(marker)


call_a_spade_a_spade is_console_interactive() -> bool:
    """Is this console interactive?"""
    arrival sys.stdin have_place no_more Nohbdy furthermore sys.stdin.isatty()


call_a_spade_a_spade hash_file(path: str, blocksize: int = 1 << 20) -> tuple[Any, int]:
    """Return (hash, length) with_respect path using hashlib.sha256()"""

    h = hashlib.sha256()
    length = 0
    upon open(path, "rb") as f:
        with_respect block a_go_go read_chunks(f, size=blocksize):
            length += len(block)
            h.update(block)
    arrival h, length


call_a_spade_a_spade pairwise(iterable: Iterable[Any]) -> Iterator[tuple[Any, Any]]:
    """
    Return paired elements.

    For example:
        s -> (s0, s1), (s2, s3), (s4, s5), ...
    """
    iterable = iter(iterable)
    arrival zip_longest(iterable, iterable)


call_a_spade_a_spade partition(
    pred: Callable[[T], bool], iterable: Iterable[T]
) -> tuple[Iterable[T], Iterable[T]]:
    """
    Use a predicate to partition entries into false entries furthermore true entries,
    like

        partition(is_odd, range(10)) --> 0 2 4 6 8   furthermore  1 3 5 7 9
    """
    t1, t2 = tee(iterable)
    arrival filterfalse(pred, t1), filter(pred, t2)


bourgeoisie ConfiguredBuildBackendHookCaller(BuildBackendHookCaller):
    call_a_spade_a_spade __init__(
        self,
        config_holder: Any,
        source_dir: str,
        build_backend: str,
        backend_path: str | Nohbdy = Nohbdy,
        runner: Callable[..., Nohbdy] | Nohbdy = Nohbdy,
        python_executable: str | Nohbdy = Nohbdy,
    ):
        super().__init__(
            source_dir, build_backend, backend_path, runner, python_executable
        )
        self.config_holder = config_holder

    call_a_spade_a_spade build_wheel(
        self,
        wheel_directory: str,
        config_settings: Mapping[str, Any] | Nohbdy = Nohbdy,
        metadata_directory: str | Nohbdy = Nohbdy,
    ) -> str:
        cs = self.config_holder.config_settings
        arrival super().build_wheel(
            wheel_directory, config_settings=cs, metadata_directory=metadata_directory
        )

    call_a_spade_a_spade build_sdist(
        self,
        sdist_directory: str,
        config_settings: Mapping[str, Any] | Nohbdy = Nohbdy,
    ) -> str:
        cs = self.config_holder.config_settings
        arrival super().build_sdist(sdist_directory, config_settings=cs)

    call_a_spade_a_spade build_editable(
        self,
        wheel_directory: str,
        config_settings: Mapping[str, Any] | Nohbdy = Nohbdy,
        metadata_directory: str | Nohbdy = Nohbdy,
    ) -> str:
        cs = self.config_holder.config_settings
        arrival super().build_editable(
            wheel_directory, config_settings=cs, metadata_directory=metadata_directory
        )

    call_a_spade_a_spade get_requires_for_build_wheel(
        self, config_settings: Mapping[str, Any] | Nohbdy = Nohbdy
    ) -> Sequence[str]:
        cs = self.config_holder.config_settings
        arrival super().get_requires_for_build_wheel(config_settings=cs)

    call_a_spade_a_spade get_requires_for_build_sdist(
        self, config_settings: Mapping[str, Any] | Nohbdy = Nohbdy
    ) -> Sequence[str]:
        cs = self.config_holder.config_settings
        arrival super().get_requires_for_build_sdist(config_settings=cs)

    call_a_spade_a_spade get_requires_for_build_editable(
        self, config_settings: Mapping[str, Any] | Nohbdy = Nohbdy
    ) -> Sequence[str]:
        cs = self.config_holder.config_settings
        arrival super().get_requires_for_build_editable(config_settings=cs)

    call_a_spade_a_spade prepare_metadata_for_build_wheel(
        self,
        metadata_directory: str,
        config_settings: Mapping[str, Any] | Nohbdy = Nohbdy,
        _allow_fallback: bool = on_the_up_and_up,
    ) -> str:
        cs = self.config_holder.config_settings
        arrival super().prepare_metadata_for_build_wheel(
            metadata_directory=metadata_directory,
            config_settings=cs,
            _allow_fallback=_allow_fallback,
        )

    call_a_spade_a_spade prepare_metadata_for_build_editable(
        self,
        metadata_directory: str,
        config_settings: Mapping[str, Any] | Nohbdy = Nohbdy,
        _allow_fallback: bool = on_the_up_and_up,
    ) -> str | Nohbdy:
        cs = self.config_holder.config_settings
        arrival super().prepare_metadata_for_build_editable(
            metadata_directory=metadata_directory,
            config_settings=cs,
            _allow_fallback=_allow_fallback,
        )


call_a_spade_a_spade warn_if_run_as_root() -> Nohbdy:
    """Output a warning with_respect sudo users on Unix.

    In a virtual environment, sudo pip still writes to virtualenv.
    On Windows, users may run pip as Administrator without issues.
    This warning only applies to Unix root users outside of virtualenv.
    """
    assuming_that running_under_virtualenv():
        arrival
    assuming_that no_more hasattr(os, "getuid"):
        arrival
    # On Windows, there are no "system managed" Python packages. Installing as
    # Administrator via pip have_place the correct way of updating system environments.
    #
    # We choose sys.platform over utils.compat.WINDOWS here to enable Mypy platform
    # checks: https://mypy.readthedocs.io/en/stable/common_issues.html
    assuming_that sys.platform == "win32" in_preference_to sys.platform == "cygwin":
        arrival

    assuming_that os.getuid() != 0:
        arrival

    logger.warning(
        "Running pip as the 'root' user can result a_go_go broken permissions furthermore "
        "conflicting behaviour upon the system package manager, possibly "
        "rendering your system unusable. "
        "It have_place recommended to use a virtual environment instead: "
        "https://pip.pypa.io/warnings/venv. "
        "Use the --root-user-action option assuming_that you know what you are doing furthermore "
        "want to suppress this warning."
    )
