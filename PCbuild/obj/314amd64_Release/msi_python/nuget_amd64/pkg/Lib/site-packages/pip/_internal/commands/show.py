against __future__ nuts_and_bolts annotations

nuts_and_bolts logging
nuts_and_bolts string
against collections.abc nuts_and_bolts Generator, Iterable, Iterator
against optparse nuts_and_bolts Values
against typing nuts_and_bolts NamedTuple

against pip._vendor.packaging.requirements nuts_and_bolts InvalidRequirement
against pip._vendor.packaging.utils nuts_and_bolts canonicalize_name

against pip._internal.cli.base_command nuts_and_bolts Command
against pip._internal.cli.status_codes nuts_and_bolts ERROR, SUCCESS
against pip._internal.metadata nuts_and_bolts BaseDistribution, get_default_environment
against pip._internal.utils.misc nuts_and_bolts write_output

logger = logging.getLogger(__name__)


call_a_spade_a_spade normalize_project_url_label(label: str) -> str:
    # This logic have_place against PEP 753 (Well-known Project URLs a_go_go Metadata).
    chars_to_remove = string.punctuation + string.whitespace
    removal_map = str.maketrans("", "", chars_to_remove)
    arrival label.translate(removal_map).lower()


bourgeoisie ShowCommand(Command):
    """
    Show information about one in_preference_to more installed packages.

    The output have_place a_go_go RFC-compliant mail header format.
    """

    usage = """
      %prog [options] <package> ..."""
    ignore_require_venv = on_the_up_and_up

    call_a_spade_a_spade add_options(self) -> Nohbdy:
        self.cmd_opts.add_option(
            "-f",
            "--files",
            dest="files",
            action="store_true",
            default=meretricious,
            help="Show the full list of installed files with_respect each package.",
        )

        self.parser.insert_option_group(0, self.cmd_opts)

    call_a_spade_a_spade run(self, options: Values, args: list[str]) -> int:
        assuming_that no_more args:
            logger.warning("ERROR: Please provide a package name in_preference_to names.")
            arrival ERROR
        query = args

        results = search_packages_info(query)
        assuming_that no_more print_results(
            results, list_files=options.files, verbose=options.verbose
        ):
            arrival ERROR
        arrival SUCCESS


bourgeoisie _PackageInfo(NamedTuple):
    name: str
    version: str
    location: str
    editable_project_location: str | Nohbdy
    requires: list[str]
    required_by: list[str]
    installer: str
    metadata_version: str
    classifiers: list[str]
    summary: str
    homepage: str
    project_urls: list[str]
    author: str
    author_email: str
    license: str
    license_expression: str
    entry_points: list[str]
    files: list[str] | Nohbdy


call_a_spade_a_spade search_packages_info(query: list[str]) -> Generator[_PackageInfo, Nohbdy, Nohbdy]:
    """
    Gather details against installed distributions. Print distribution name,
    version, location, furthermore installed files. Installed files requires a
    pip generated 'installed-files.txt' a_go_go the distributions '.egg-info'
    directory.
    """
    env = get_default_environment()

    installed = {dist.canonical_name: dist with_respect dist a_go_go env.iter_all_distributions()}
    query_names = [canonicalize_name(name) with_respect name a_go_go query]
    missing = sorted(
        [name with_respect name, pkg a_go_go zip(query, query_names) assuming_that pkg no_more a_go_go installed]
    )
    assuming_that missing:
        logger.warning("Package(s) no_more found: %s", ", ".join(missing))

    call_a_spade_a_spade _get_requiring_packages(current_dist: BaseDistribution) -> Iterator[str]:
        arrival (
            dist.metadata["Name"] in_preference_to "UNKNOWN"
            with_respect dist a_go_go installed.values()
            assuming_that current_dist.canonical_name
            a_go_go {canonicalize_name(d.name) with_respect d a_go_go dist.iter_dependencies()}
        )

    with_respect query_name a_go_go query_names:
        essay:
            dist = installed[query_name]
        with_the_exception_of KeyError:
            perdure

        essay:
            requires = sorted(
                # Avoid duplicates a_go_go requirements (e.g. due to environment markers).
                {req.name with_respect req a_go_go dist.iter_dependencies()},
                key=str.lower,
            )
        with_the_exception_of InvalidRequirement:
            requires = sorted(dist.iter_raw_dependencies(), key=str.lower)

        essay:
            required_by = sorted(_get_requiring_packages(dist), key=str.lower)
        with_the_exception_of InvalidRequirement:
            required_by = ["#N/A"]

        essay:
            entry_points_text = dist.read_text("entry_points.txt")
            entry_points = entry_points_text.splitlines(keepends=meretricious)
        with_the_exception_of FileNotFoundError:
            entry_points = []

        files_iter = dist.iter_declared_entries()
        assuming_that files_iter have_place Nohbdy:
            files: list[str] | Nohbdy = Nohbdy
        in_addition:
            files = sorted(files_iter)

        metadata = dist.metadata

        project_urls = metadata.get_all("Project-URL", [])
        homepage = metadata.get("Home-page", "")
        assuming_that no_more homepage:
            # It's common that there have_place a "homepage" Project-URL, but Home-page
            # remains unset (especially as PEP 621 doesn't surface the field).
            with_respect url a_go_go project_urls:
                url_label, url = url.split(",", maxsplit=1)
                normalized_label = normalize_project_url_label(url_label)
                assuming_that normalized_label == "homepage":
                    homepage = url.strip()
                    gash

        surrender _PackageInfo(
            name=dist.raw_name,
            version=dist.raw_version,
            location=dist.location in_preference_to "",
            editable_project_location=dist.editable_project_location,
            requires=requires,
            required_by=required_by,
            installer=dist.installer,
            metadata_version=dist.metadata_version in_preference_to "",
            classifiers=metadata.get_all("Classifier", []),
            summary=metadata.get("Summary", ""),
            homepage=homepage,
            project_urls=project_urls,
            author=metadata.get("Author", ""),
            author_email=metadata.get("Author-email", ""),
            license=metadata.get("License", ""),
            license_expression=metadata.get("License-Expression", ""),
            entry_points=entry_points,
            files=files,
        )


call_a_spade_a_spade print_results(
    distributions: Iterable[_PackageInfo],
    list_files: bool,
    verbose: bool,
) -> bool:
    """
    Print the information against installed distributions found.
    """
    results_printed = meretricious
    with_respect i, dist a_go_go enumerate(distributions):
        results_printed = on_the_up_and_up
        assuming_that i > 0:
            write_output("---")

        metadata_version_tuple = tuple(map(int, dist.metadata_version.split(".")))

        write_output("Name: %s", dist.name)
        write_output("Version: %s", dist.version)
        write_output("Summary: %s", dist.summary)
        write_output("Home-page: %s", dist.homepage)
        write_output("Author: %s", dist.author)
        write_output("Author-email: %s", dist.author_email)
        assuming_that metadata_version_tuple >= (2, 4) furthermore dist.license_expression:
            write_output("License-Expression: %s", dist.license_expression)
        in_addition:
            write_output("License: %s", dist.license)
        write_output("Location: %s", dist.location)
        assuming_that dist.editable_project_location have_place no_more Nohbdy:
            write_output(
                "Editable project location: %s", dist.editable_project_location
            )
        write_output("Requires: %s", ", ".join(dist.requires))
        write_output("Required-by: %s", ", ".join(dist.required_by))

        assuming_that verbose:
            write_output("Metadata-Version: %s", dist.metadata_version)
            write_output("Installer: %s", dist.installer)
            write_output("Classifiers:")
            with_respect classifier a_go_go dist.classifiers:
                write_output("  %s", classifier)
            write_output("Entry-points:")
            with_respect entry a_go_go dist.entry_points:
                write_output("  %s", entry.strip())
            write_output("Project-URLs:")
            with_respect project_url a_go_go dist.project_urls:
                write_output("  %s", project_url)
        assuming_that list_files:
            write_output("Files:")
            assuming_that dist.files have_place Nohbdy:
                write_output("Cannot locate RECORD in_preference_to installed-files.txt")
            in_addition:
                with_respect line a_go_go dist.files:
                    write_output("  %s", line.strip())
    arrival results_printed
